# [目录](null) 
* [第1章 快速入门C++](content/chapter1/1.0-Getting-started-with-CPP.md)
	* [1.1 Hello World](content/chapter1/1.1-Hello-World.md)
	* [1.2 注释](content/chapter1/1.2-Comments.md)
	* [1.3 The standard C++ compilation process](null) 
	* [1.4 Function](null) 
	* [1.5 Visibility of function prototypes and declarations](null) 
	* [1.6 Preprocessor](null) 
* [第2章 Literals](null) 
	* [2.1 this](null) 
	* [2.2 Integer literal](null) 
	* [2.3 true](null) 
	* [2.4 false](null) 
	* [2.5 nullptr](null) 
* [第3章 operator precedence](null) 
	* [3.1 Logical && and || operators: short-circuit](null) 
	* [3.2 Unary Operators](null) 
	* [3.3 Arithmetic operators](null) 
	* [3.4 Logical AND and OR operators](null) 
* [第4章 Floating Point Arithmetic](null) 
	* [4.1 Floating Point Numbers are Weird](null) 
* [第5章 Bit Operators](null) 
	* [5.1 | - bitwise OR](null) 
	* [5.2 ^ - bitwise XOR (exclusive OR)](null) 
	* [5.3 & - bitwise AND](null) 
	* [5.4 << - left shift](null) 
	* [5.5 >> - right shift](null) 
* [第6章 Bit Manipulation](null) 
	* [6.1 Remove rightmost set bit](null) 
	* [6.2 Set all bits](null) 
	* [6.3 Toggling a bit](null) 
	* [6.4 Checking a bit](null) 
	* [6.5 Counting bits set](null) 
	* [6.6 Check if an integer is a power of 2](null) 
	* [6.7 Setting a bit](null) 
	* [6.8 Clearing a bit](null) 
	* [6.9 Changing the nth bit to x](null) 
	* [6.10 Bit Manipulation Application: Small to Capital Letter](null) 
* [第7章 Bit fields](null) 
	* [7.1 Declaration and Usage](null) 
* [第8章 Arrays](null) 
	* [8.1 Array initialization](null) 
	* [8.2 A fixed size raw array matrix (that is, a 2D raw array)](null) 
	* [8.3 Dynamically sized raw array](null) 
	* [8.4 Array size: type safe at compile time](null) 
	* [8.5 Expanding dynamic size array by using std::vector](null) 
	* [8.6 A dynamic size matrix using std::vector for storage](null) 
* [第9章 Iterators](null) 
	* [9.1 Overview](null) 
	* [9.2 Vector Iterator](null) 
	* [9.3 Map Iterator](null) 
	* [9.4 Reverse Iterators](null) 
	* [9.5 Stream Iterators](null) 
	* [9.6 C Iterators (Pointers)](null) 
	* [9.7 Write your own generator-backed iterator](null) 
* [第10章 Basic input/output in c++](null) 
	* [10.1 user input and standard output](null) 
* [第11章 Loops](null) 
	* [11.1 Range-Based For](null) 
	* [11.2 For loop](null) 
	* [11.3 While loop](null) 
	* [11.4 Do-while loop](null) 
	* [11.5 Loop Control statements : Break and Continue](null) 
	* [11.6 Declaration of variables in conditions](null) 
	* [11.7 Range-for over a sub-range](null) 
* [第12章 File I/O](null) 
	* [12.1 Writing to a file](null) 
	* [12.2 Opening a file](null) 
	* [12.3 Reading from a file](null) 
	* [12.4 Opening modes](null) 
	* [12.5 Reading an ASCII file into a std::string](null) 
	* [12.6 Writing files with non-standard locale settings](null) 
	* [12.7 Checking end of file inside a loop condition, bad practice?](null) 
	* [12.8 Flushing a stream](null) 
	* [12.9 Reading a file into a container](null) 
	* [12.10 Copying a file](null) 
	* [12.11 Closing a file](null) 
	* [12.12 Reading a `struct` from a formatted text file](null) 
* [第13章 C++ Streams](null) 
	* [13.1 String streams](null) 
	* [13.2 Printing collections with iostream](null) 
* [第14章 Stream manipulators](null) 
	* [14.1 Stream manipulators](null) 
	* [14.2 Output stream manipulators](null) 
	* [14.3 Input stream manipulators](null) 
* [第15章 Flow Control](null) 
	* [15.1 case](null) 
	* [15.2 switch](null) 
	* [15.3 catch](null) 
	* [15.4 throw](null) 
	* [15.5 default](null) 
	* [15.6 try](null) 
	* [15.7 if](null) 
	* [15.8 else](null) 
	* [15.9 Conditional Structures: if, ifelse](null) 
	* [15.10 goto](null) 
	* [15.11 Jump statements : break, continue, goto, exit](null) 
	* [15.12 return](null) 
* [第16章 Metaprogramming](null) 
	* [16.1 Calculating Factorials](null) 
	* [16.2 Iterating over a parameter pack](null) 
	* [16.3 Iterating with std::integer_sequence](null) 
	* [16.4 Tag Dispatching](null) 
	* [16.5 Detect Whether Expression is Valid](null) 
	* [16.6 If-then-else](null) 
	* [16.7 Manual distinction of types when given any type T](null) 
	* [16.8 Calculating power with C++11 (and higher)](null) 
	* [16.9 Generic Min/Max with variable argument count](null) 
* [第17章 const keyword](null) 
	* [17.1 Avoiding duplication of code in const and non-const getter methods](null) 
	* [17.2 Const member functions](null) 
	* [17.3 Const local variables](null) 
	* [17.4 Const pointers](null) 
* [第18章 mutable keyword](null) 
	* [18.1 mutable lambdas](null) 
	* [18.2 non-static class member modifier](null) 
* [第19章 Friend keyword](null) 
	* [19.1 Friend function](null) 
	* [19.2 Friend method](null) 
	* [19.3 Friend class](null) 
* [第20章 Type Keywords](null) 
	* [20.1 class](null) 
	* [20.2 enum](null) 
	* [20.3 struct](null) 
	* [20.4 union](null) 
* [第21章 Basic Type Keywords](null) 
	* [21.1 char](null) 
	* [21.2 char16_t](null) 
	* [21.3 char32_t](null) 
	* [21.4 int](null) 
	* [21.5 void](null) 
	* [21.6 wchar_t](null) 
	* [21.7 float](null) 
	* [21.8 double](null) 
	* [21.9 long](null) 
	* [21.10 short](null) 
	* [21.11 bool](null) 
* [第22章 Variable Declaration Keywords](null) 
	* [22.1 decltype](null) 
	* [22.2 const](null) 
	* [22.3 volatile](null) 
	* [22.4 signed](null) 
	* [22.5 unsigned](null) 
* [第23章 Keywords](null) 
	* [23.1 asm](null) 
	* [23.2 Dierent keywords](null) 
	* [23.3 typename](null) 
	* [23.4 explicit](null) 
	* [23.5 sizeof](null) 
	* [23.6 noexcept](null) 
* [第24章 Returning several values from a function](null) 
	* [24.1 Using std::tuple](null) 
	* [24.2 Structured Bindings](null) 
	* [24.3 Using struct](null) 
	* [24.4 Using Output Parameters](null) 
	* [24.5 Using a Function Object Consumer](null) 
	* [24.6 Using std::pair](null) 
	* [24.7 Using std::array](null) 
	* [24.8 Using Output Iterator](null) 
	* [24.9 Using std::vector](null) 
* [第25章 Polymorphism](null) 
	* [25.1 Define polymorphic classes](null) 
	* [25.2 Safe downcasting](null) 
	* [25.3 Polymorphism & Destructors](null) 
* [第26章 References](null) 
	* [26.1 Defining a reference](null) 
* [第27章 Value and Reference Semantics](null) 
	* [27.1 Definitions](null) 
	* [27.2 Deep copying and move support](null) 
* [第28章 C++ function "call by value" vs](null) 
	* [28.1 Call by value](null) 
* [第29章 Copying vs Assignment](null) 
	* [29.1 Assignment Operator](null) 
	* [29.2 Copy Constructor](null) 
	* [29.3 Copy Constructor Vs Assignment Constructor](null) 
* [第30章 Pointers](null) 
	* [30.1 Pointer Operations](null) 
	* [30.2 Pointer basics](null) 
	* [30.3 Pointer Arithmetic](null) 
* [第31章 Pointers to members](null) 
	* [31.1 Pointers to static member functions](null) 
	* [31.2 Pointers to member functions](null) 
	* [31.3 Pointers to member variables](null) 
	* [31.4 Pointers to static member variables](null) 
* [第32章 The This Pointer](null) 
	* [32.1 this Pointer](null) 
	* [32.2 Using the this Pointer to Access Member Data](null) 
	* [32.3 Using the this Pointer to Dierentiate Between Member Data and Parameters](null) 
	* [32.4 this Pointer CV-Qualifiers](null) 
	* [32.5 this Pointer Ref-Qualifiers](null) 
* [第33章 Smart Pointers](null) 
	* [33.1 Unique ownership (std::unique_ptr)](null) 
	* [33.2 Sharing ownership (std::shared_ptr)](null) 
	* [33.3 Sharing with temporary ownership (std::weak_ptr)](null) 
	* [33.4 Using custom deleters to create a wrapper to a C interface](null) 
	* [33.5 Unique ownership without move semantics (auto_ptr)](null) 
	* [33.6 Casting std::shared_ptr pointers](null) 
	* [33.7 Writing a smart pointer: value_ptr](null) 
	* [33.8 Getting a shared_ptr referring to this](null) 
* [第34章 Classes/Structures](null) 
	* [34.1 Class basics](null) 
	* [34.2 Final classes and structs](null) 
	* [34.3 Access specifiers](null) 
	* [34.4 Inheritance](null) 
	* [34.5 Friendship](null) 
	* [34.6 Virtual Inheritance](null) 
	* [34.7 Private inheritance: restricting base class interface](null) 
	* [34.8 Accessing class members](null) 
	* [34.9 Member Types and Aliases](null) 
	* [34.10 Nested Classes/Structures](null) 
	* [34.11 Unnamed struct/class](null) 
	* [34.12 Static class members](null) 
	* [34.13 Multiple Inheritance](null) 
	* [34.14 Non-static member functions](null) 
* [第35章 Function Overloading](null) 
	* [35.1 What is Function Overloading?](null) 
	* [35.2 Return Type in Function Overloading](null) 
	* [35.3 Member Function cv-qualifier Overloading](null) 
* [第36章 Operator Overloading](null) 
	* [36.1 Arithmetic operators](null) 
	* [36.2 Array subscript operator](null) 
	* [36.3 Conversion operators](null) 
	* [36.4 Complex Numbers Revisited](null) 
	* [36.5 Named operators](null) 
	* [36.6 Unary operators](null) 
	* [36.7 Comparison operators](null) 
	* [36.8 Assignment operator](null) 
	* [36.9 Function call operator](null) 
	* [36.10 Bitwise NOT operator](null) 
	* [36.11 Bit shift operators for I/O](null) 
* [第37章 Function Template Overloading](null) 
	* [37.1 What is a valid function template overloading?](null) 
* [第38章 Virtual Member Functions](null) 
	* [38.1 Final virtual functions](null) 
	* [38.2 Using override with virtual in C++11 and later](null) 
	* [38.3 Virtual vs non-virtual member functions](null) 
	* [38.4 Behaviour of virtual functions in constructors and destructors](null) 
	* [38.5 Pure virtual functions](null) 
* [第39章 Inline functions](null) 
	* [39.1 Non-member inline function definition](null) 
	* [39.2 Member inline functions](null) 
	* [39.3 What is function inlining?](null) 
	* [39.4 Non-member inline function declaration](null) 
* [第40章 Special Member Functions](null) 
	* [40.1 Default Constructor](null) 
	* [40.2 Destructor](null) 
	* [40.3 Copy and swap](null) 
	* [40.4 Implicit Move and Copy](null) 
* [第41章 Non-Static Member Functions](null) 
	* [41.1 Non-static Member Functions](null) 
	* [41.2 Encapsulation](null) 
	* [41.3 Name Hiding & Importing](null) 
	* [41.4 Virtual Member Functions](null) 
	* [41.5 Const Correctness](null) 
* [第42章 Constant class member functions](null) 
	* [42.1 constant member function](null) 
* [第43章 C++ Containers](null) 
	* [43.1 C++ Containers Flowchart](null) 
* [第44章 Namespaces](null) 
	* [44.1 What are namespaces?](null) 
	* [44.2 Argument Dependent Lookup](null) 
	* [44.3 Extending namespaces](null) 
	* [44.4 Using directive](null) 
	* [44.5 Making namespaces](null) 
	* [44.6 Unnamed/anonymous namespaces](null) 
	* [44.7 Compact nested namespaces](null) 
	* [44.8 Namespace alias](null) 
	* [44.9 Inline namespace](null) 
	* [44.10 Aliasing a long namespace](null) 
	* [44.11 Alias Declaration scope](null) 
* [第45章 Header Files](null) 
	* [45.1 Basic Example](null) 
	* [45.2 Templates in Header Files](null) 
* [第46章 Using declaration](null) 
	* [46.1 Importing names individually from a namespace](null) 
	* [46.2 Redeclaring members from a base class to avoid name hiding](null) 
	* [46.3 Inheriting constructors](null) 
* [第47章 std::string](null) 
	* [47.1 Tokenize](null) 
	* [47.2 Conversion to (const) char*](null) 
	* [47.3 Using the std::string_view class](null) 
	* [47.4 Conversion to std::wstring](null) 
	* [47.5 Lexicographical comparison](null) 
	* [47.6 Trimming characters at start/end](null) 
	* [47.7 String replacement](null) 
	* [47.8 Converting to std::string](null) 
	* [47.9 Splitting](null) 
	* [47.10 Accessing a character](null) 
	* [47.11 Checking if a string is a prefix of another](null) 
	* [47.12 Looping through each character](null) 
	* [47.13 Conversion to integers/floating point types](null) 
	* [47.14 Concatenation](null) 
	* [47.15 Converting between character encodings](null) 
	* [47.16 Finding character(s) in a string](null) 
* [第48章 std::array](null) 
	* [48.1 Initializing an std::array](null) 
	* [48.2 Element access](null) 
	* [48.3 Iterating through the Array](null) 
	* [48.4 Checking size of the Array](null) 
	* [48.5 Changing all array elements at once](null) 
* [第49章 std::vector](null) 
	* [49.1 Accessing Elements](null) 
	* [49.2 Initializing a std::vector](null) 
	* [49.3 Deleting Elements](null) 
	* [49.4 Iterating Over std::vector](null) 
	* [49.5 vector<bool>: The Exception To So Many, So Many Rules](null) 
	* [49.6 Inserting Elements](null) 
	* [49.7 Using std::vector as a C array](null) 
	* [49.8 Finding an Element in std::vector](null) 
	* [49.9 Concatenating Vectors](null) 
	* [49.10 Matrices Using Vectors](null) 
	* [49.11 Using a Sorted Vector for Fast Element Lookup](null) 
	* [49.12 Reducing the Capacity of a Vector](null) 
	* [49.13 Vector size and capacity](null) 
	* [49.14 Iterator/Pointer Invalidation](null) 
	* [49.15 Find max and min Element and Respective Index in a Vector](null) 
	* [49.16 Converting an array to std::vector](null) 
	* [49.17 Functions Returning Large Vectors](null) 
* [第50章 std::map](null) 
	* [50.1 Accessing elements](null) 
	* [50.2 Inserting elements](null) 
	* [50.3 Searching in std::map or in std::multimap](null) 
	* [50.4 Initializing a std::map or std::multimap](null) 
	* [50.5 Checking number of elements](null) 
	* [50.6 Types of Maps](null) 
	* [50.7 Deleting elements](null) 
	* [50.8 Iterating over std::map or std::multimap](null) 
	* [50.9 Creating std::map with user-defined types as key](null) 
* [第51章 std::optional](null) 
	* [51.1 Using optionals to represent the absence of a value](null) 
	* [51.2 optional as return value](null) 
	* [51.3 value_or](null) 
	* [51.4 Introduction](null) 
	* [51.5 Using optionals to represent the failure of a function](null) 
* [第52章 std::function: To wrap any element that is callable](null) 
	* [52.1 Simple usage](null) 
	* [52.2 std::function used with std::bind](null) 
	* [52.3 Binding std::function to a dierent callable types](null) 
	* [52.4 Storing function arguments in std::tuple](null) 
	* [52.5 std::function with lambda and std::bind](null) 
	* [52.6 `function` overhead](null) 
* [第53章 std::forward_list](null) 
	* [53.1 Example](null) 
	* [53.2 Methods](null) 
* [第54章 std::pair](null) 
	* [54.1 Compare operators](null) 
	* [54.2 Creating a Pair and accessing the elements](null) 
* [第55章 std::atomics](null) 
	* [55.1 atomic types](null) 
* [第56章 std::variant](null) 
	* [56.1 Create pseudo-method pointers](null) 
	* [56.2 Basic std::variant use](null) 
	* [56.3 Constructing a `std::variant`](null) 
* [第57章 std::iomanip](null) 
	* [57.1 std::setprecision](null) 
	* [57.2 std::setfill](null) 
	* [57.3 std::setiosflags](null) 
	* [57.4 std::setw](null) 
* [第58章 std::any](null) 
	* [58.1 Basic usage](null) 
* [第59章 std::set and std::multiset](null) 
	* [59.1 Changing the default sort of a set](null) 
	* [59.2 Deleting values from a set](null) 
	* [59.3 Inserting values in a set](null) 
	* [59.4 Inserting values in a multiset](null) 
	* [59.5 Searching values in set and multiset](null) 
* [第60章 std::integer_sequence](null) 
	* [60.1 Turn a std::tuple<T.> into function parameters](null) 
	* [60.2 Create a parameter pack consisting of integers](null) 
	* [60.3 Turn a sequence of indices into copies of an element](null) 
* [第61章 Using std::unordered_map](null) 
	* [61.1 Declaration and Usage](null) 
	* [61.2 Some Basic Functions](null) 
* [第62章 Standard Library Algorithms](null) 
	* [62.1 std::next_permutation](null) 
	* [62.2 std::for_each](null) 
	* [62.3 std::accumulate](null) 
	* [62.4 std::find](null) 
	* [62.5 std::min_element](null) 
	* [62.6 std::find_if](null) 
	* [62.7 Using std::nth_element To Find The Median (Or Other Quantiles)](null) 
	* [62.8 std::count](null) 
	* [62.9 std::count_if](null) 
* [第63章 The ISO C++ Standard](null) 
	* [63.1 Current Working Drafts](null) 
	* [63.2 C++17](null) 
	* [63.3 C++11](null) 
	* [63.4 C++14](null) 
	* [63.5 C++98](null) 
	* [63.6 C++03](null) 
	* [63.7 C++20](null) 
* [第64章 Inline variables](null) 
	* [64.1 Defining a static data member in the class definition](null) 
* [第65章 Random number generation](null) 
	* [65.1 True random value generator](null) 
	* [65.2 Generating a pseudo-random number](null) 
	* [65.3 Using the generator for multiple distributions](null) 
* [第66章 Date and time using <chrono> header](null) 
	* [66.1 Measuring time using <chrono>](null) 
	* [66.2 Find number of days between two dates](null) 
* [第67章 Sorting](null) 
	* [67.1 Sorting and sequence containers](null) 
	* [67.2 sorting with std::map (ascending and descending)](null) 
	* [67.3 Sorting sequence containers by overloaded less operator](null) 
	* [67.4 Sorting sequence containers using compare function](null) 
	* [67.5 Sorting sequence containers using lambda expressions (C++11)](null) 
	* [67.6 Sorting built-in arrays](null) 
	* [67.7 Sorting sequence containers with specifed ordering](null) 
* [第68章 Enumeration](null) 
	* [68.1 Iteration over an enum](null) 
	* [68.2 Scoped enums](null) 
	* [68.3 Enum forward declaration in C++11](null) 
	* [68.4 Basic Enumeration Declaration](null) 
	* [68.5 Enumeration in switch statements](null) 
* [第69章 Iteration](null) 
	* [69.1 break](null) 
	* [69.2 continue](null) 
	* [69.3 do](null) 
	* [69.4 while](null) 
	* [69.5 range-based for loop](null) 
	* [69.6 for](null) 
* [第70章 Regular expressions](null) 
	* [70.1 Basic regex_match and regex_search Examples](null) 
	* [70.2 regex_iterator Example](null) 
	* [70.3 Anchors](null) 
	* [70.4 regex_replace Example](null) 
	* [70.5 regex_token_iterator Example](null) 
	* [70.6 Quantifiers](null) 
	* [70.7 Splitting a string](null) 
* [第71章 Implementation-defined behavior](null) 
	* [71.1 Size of integral types](null) 
	* [71.2 Char might be unsigned or signed](null) 
	* [71.3 Ranges of numeric types](null) 
	* [71.4 Value representation of floating point types](null) 
	* [71.5 Overflow when converting from integer to signed integer](null) 
	* [71.6 Underlying type (and hence size) of an enum](null) 
	* [71.7 Numeric value of a pointer](null) 
	* [71.8 Number of bits in a byte](null) 
* [第72章 Exceptions](null) 
	* [72.1 Catching exceptions](null) 
	* [72.2 Rethrow (propagate) exception](null) 
	* [72.3 Best practice: throw by value, catch by const reference](null) 
	* [72.4 Custom exception](null) 
	* [72.5 std::uncaught_exceptions](null) 
	* [72.6 Function Try Block for regular function](null) 
	* [72.7 Nested exception](null) 
	* [72.8 Function Try Blocks In constructor](null) 
	* [72.9 Function Try Blocks In destructor](null) 
* [第73章 Lambdas](null) 
	* [73.1 What is a lambda expression?](null) 
	* [73.2 Specifying the return type](null) 
	* [73.3 Capture by value](null) 
	* [73.4 Recursive lambdas](null) 
	* [73.5 Default capture](null) 
	* [73.6 Class lambdas and capture of this](null) 
	* [73.7 Capture by reference](null) 
	* [73.8 Generic lambdas](null) 
	* [73.9 Using lambdas for inline parameter pack unpacking](null) 
	* [73.10 Generalized capture](null) 
	* [73.11 Conversion to function pointer](null) 
	* [73.12 Porting lambda functions to C++03 using functors](null) 
* [第74章 Value Categories](null) 
	* [74.1 Value Category Meanings](null) 
	* [74.2 rvalue](null) 
	* [74.3 xvalue](null) 
	* [74.4 prvalue](null) 
	* [74.5 lvalue](null) 
	* [74.6 glvalue](null) 
* [第75章 Preprocessor](null) 
	* [75.1 Include Guards](null) 
	* [75.2 Conditional logic and cross-platform handling](null) 
	* [75.3 X-macros](null) 
	* [75.4 Macros](null) 
	* [75.5 Predefined macros](null) 
	* [75.6 Preprocessor Operators](null) 
	* [75.7 #pragma once](null) 
	* [75.8 Preprocessor error messages](null) 
* [第76章 Data Structures in C++](null) 
	* [76.1 Linked List implementation in C++](null) 
* [第77章 Templates](null) 
	* [77.1 Basic Class Template](null) 
	* [77.2 Function Templates](null) 
	* [77.3 Variadic template data structures](null) 
	* [77.4 Argument forwarding](null) 
	* [77.5 Partial template specialization](null) 
	* [77.6 Template Specialization](null) 
	* [77.7 Alias template](null) 
	* [77.8 Explicit instantiation](null) 
	* [77.9 Non-type template parameter](null) 
	* [77.10 Declaring non-type template arguments with auto](null) 
	* [77.11 Template template parameters](null) 
	* [77.12 Default template parameter value](null) 
* [第78章 Expression templates](null) 
	* [78.1 A basic example illustrating expression templates](null) 
* [第79章 Curiously Recurring Template Pattern (CRTP)](null) 
	* [79.1 The Curiously Recurring Template Pattern (CRTP)](null) 
	* [79.2 CRTP to avoid code duplication](null) 
* [第80章 Threading](null) 
	* [80.1 Creating a std::thread](null) 
	* [80.2 Passing a reference to a thread](null) 
	* [80.3 Using std::async instead of std::thread](null) 
	* [80.4 Basic Synchronization](null) 
	* [80.5 Create a simple thread pool](null) 
	* [80.6 Ensuring a thread is always joined](null) 
	* [80.7 Operations on the current thread](null) 
	* [80.8 Using Condition Variables](null) 
	* [80.9 Thread operations](null) 
	* [80.10 Thread-local storage](null) 
	* [80.11 Reassigning thread objects](null) 
* [第81章 Thread synchronization structures](null) 
	* [81.1 std::condition_variable_any, std::cv_status](null) 
	* [81.2 std::shared_lock](null) 
	* [81.3 std::call_once, std::once_flag](null) 
	* [81.4 Object locking for effcient access](null) 
* [第82章 The Rule of Three, Five, And Zero](null) 
	* [82.1 Rule of Zero](null) 
	* [82.2 Rule of Five](null) 
	* [82.3 Rule of Three](null) 
	* [82.4 Self-assignment Protection](null) 
* [第83章 RAII: Resource Acquisition Is Initialization](null) 
	* [83.1 Locking](null) 
	* [83.2 ScopeSuccess (c++17)](null) 
	* [83.3 ScopeFail (c++17)](null) 
	* [83.4 Finally/ScopeExit](null) 
* [第84章 RTTI: Run-Time Type Information](null) 
	* [84.1 dynamic_cast](null) 
	* [84.2 The typeid keyword](null) 
	* [84.3 Name of a type](null) 
	* [84.4 When to use which cast in c++](null) 
* [第85章 Mutexes](null) 
	* [85.1 Mutex Types](null) 
	* [85.2 std::lock](null) 
	* [85.3 std::unique_lock, std::shared_lock, std::lock_guard](null) 
	* [85.4 Strategies for lock classes: std::try_to_lock, std::adopt_lock, std::defer_lock](null) 
	* [85.5 std::mutex](null) 
	* [85.6 std::scoped_lock (C++ 17)](null) 
* [第86章 Recursive Mutex](null) 
	* [86.1 std::recursive_mutex](null) 
* [第87章 Semaphore](null) 
	* [87.1 Semaphore C++ 11](null) 
	* [87.2 Semaphore class in action](null) 
* [第88章 Futures and Promises](null) 
	* [88.1 Async operation classes](null) 
	* [88.2 std::future and std::promise](null) 
	* [88.3 Deferred async example](null) 
	* [88.4 std::packaged_task and std::future](null) 
	* [88.5 std::future_error and std::future_errc](null) 
	* [88.6 std::future and std::async](null) 
* [第89章 Atomic Types](null) 
	* [89.1 Multi-threaded Access](null) 
* [第90章 Type Erasure](null) 
	* [90.1 A move-only `std::function`](null) 
	* [90.2 Erasing down to a Regular type with manual vtable](null) 
	* [90.3 Basic mechanism](null) 
	* [90.4 Erasing down to a contiguous buer of T](null) 
	* [90.5 Type erasing type erasure with std::any](null) 
* [第91章 Explicit type conversions](null) 
	* [91.1 C-style casting](null) 
	* [91.2 Casting away constness](null) 
	* [91.3 Base to derived conversion](null) 
	* [91.4 Conversion between pointer and integer](null) 
	* [91.5 Conversion by explicit constructor or explicit conversion function](null) 
	* [91.6 Implicit conversion](null) 
	* [91.7 Enum conversions](null) 
	* [91.8 Derived to base conversion for pointers to members](null) 
	* [91.9 void* to T*](null) 
	* [91.10 Type punning conversion](null) 
* [第92章 Unnamed types](null) 
	* [92.1 Unnamed classes](null) 
	* [92.2 As a type alias](null) 
	* [92.3 Anonymous members](null) 
	* [92.4 Anonymous Union](null) 
* [第93章 Type Traits](null) 
	* [93.1 Type Properties](null) 
	* [93.2 Standard type traits](null) 
	* [93.3 Type relations with std::is_same<T, T>](null) 
	* [93.4 Fundamental type traits](null) 
* [第94章 Return Type Covariance](null) 
	* [94.1 Covariant result version of the base example, static type checking](null) 
	* [94.2 Covariant smart pointer result (automated cleanup)](null) 
* [第95章 Layout of object types](null) 
	* [95.1 Class types](null) 
	* [95.2 Arithmetic types](null) 
	* [95.3 Arrays](null) 
* [第96章 Type Inference](null) 
	* [96.1 Data Type: Auto](null) 
	* [96.2 Lambda auto](null) 
	* [96.3 Loops and auto](null) 
* [第97章 Typedef and type aliases](null) 
	* [97.1 Basic typedef syntax](null) 
	* [97.2 More complex uses of typedef](null) 
	* [97.3 Declaring multiple types with typedef](null) 
	* [97.4 Alias declaration with "using"](null) 
* [第98章 type deduction](null) 
	* [98.1 Template parameter deduction for constructors](null) 
	* [98.2 Auto Type Deduction](null) 
	* [98.3 Template Type Deduction](null) 
* [第99章 Trailing return type](null) 
	* [99.1 Avoid qualifying a nested type name](null) 
	* [99.2 Lambda expressions](null) 
* [第100章 Alignment](null) 
	* [100.1 Controlling alignment](null) 
	* [100.2 Querying the alignment of a type](null) 
* [第101章 Perfect Forwarding](null) 
	* [101.1 Factory functions](null) 
* [第102章 decltype](null) 
	* [102.1 Basic Example](null) 
	* [102.2 Another example](null) 
* [第103章 SFINAE (Substitution Failure Is Not An Error)](null) 
	* [103.1 What is SFINAE](null) 
	* [103.2 void_t](null) 
	* [103.3 enable_if](null) 
	* [103.4 is_detected](null) 
	* [103.5 Overload resolution with a large number of options](null) 
	* [103.6 trailing decltype in function templates](null) 
	* [103.7 enable_if_all / enable_if_any](null) 
* [第104章 Undefined Behavior](null) 
	* [104.1 Reading or writing through a null pointer](null) 
	* [104.2 Using an uninitialized local variable](null) 
	* [104.3 Accessing an out-of-bounds index](null) 
	* [104.4 Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor](null) 
	* [104.5 Extending the `std` or `posix` Namespace](null) 
	* [104.6 Invalid pointer arithmetic](null) 
	* [104.7 No return statement for a function with a non-void return type](null) 
	* [104.8 Accessing a dangling reference](null) 
	* [104.9 Integer division by zero](null) 
	* [104.10 Shifting by an invalid number of positions](null) 
	* [104.11 Incorrect pairing of memory allocation and deallocation](null) 
	* [104.12 Signed Integer Overflow](null) 
	* [104.13 Multiple non-identical definitions (the One Definition Rule)](null) 
	* [104.14 Modifying a const object](null) 
	* [104.15 Returning from a [[noreturn]] function](null) 
	* [104.16 Infinite template recursion](null) 
	* [104.17 Overflow during conversion to or from floating point type](null) 
	* [104.18 Modifying a string literal](null) 
	* [104.19 Accessing an object as the wrong type](null) 
	* [104.20 Invalid derived-to-base conversion for pointers to members](null) 
	* [104.21 Destroying an object that has already been destroyed](null) 
	* [104.22 Access to nonexistent member through pointer to member](null) 
	* [104.23 Invalid base-to-derived static cast](null) 
	* [104.24 Floating point overflow](null) 
	* [104.25 Calling (Pure) Virtual Members From Constructor Or Destructor](null) 
	* [104.26 Function call through mismatched function pointer type](null) 
* [第105章 Overload resolution](null) 
	* [105.1 Categorization of argument to parameter cost](null) 
	* [105.2 Arithmetic promotions and conversions](null) 
	* [105.3 Overloading on Forwarding Reference](null) 
	* [105.4 Exact match](null) 
	* [105.5 Overloading on constness and volatility](null) 
	* [105.6 Name lookup and access checking](null) 
	* [105.7 Overloading within a class hierarchy](null) 
	* [105.8 Steps of Overload Resolution](null) 
* [第106章 Move Semantics](null) 
	* [106.1 Move semantics](null) 
	* [106.2 Using std::move to reduce complexity from O(n²) to O(n)](null) 
	* [106.3 Move constructor](null) 
	* [106.4 Re-use a moved object](null) 
	* [106.5 Move assignment](null) 
	* [106.6 Using move semantics on containers](null) 
* [第107章 Pimpl Idiom](null) 
	* [107.1 Basic Pimpl idiom](null) 
* [第108章 auto](null) 
	* [108.1 Basic auto sample](null) 
	* [108.2 Generic lambda (C++14)](null) 
	* [108.3 auto and proxy objects](null) 
	* [108.4 auto and Expression Templates](null) 
	* [108.5 auto, const, and references](null) 
	* [108.6 Trailing return type](null) 
* [第109章 Copy Elision](null) 
	* [109.1 Purpose of copy elision](null) 
	* [109.2 Guaranteed copy elision](null) 
	* [109.3 Parameter elision](null) 
	* [109.4 Return value elision](null) 
	* [109.5 Named return value elision](null) 
	* [109.6 Copy initialization elision](null) 
* [第110章 Fold Expressions](null) 
	* [110.1 Unary Folds](null) 
	* [110.2 Binary Folds](null) 
	* [110.3 Folding over a comma](null) 
* [第111章 Unions](null) 
	* [111.1 Undefined Behavior](null) 
	* [111.2 Basic Union Features](null) 
	* [111.3 Typical Use](null) 
* [第112章 Design pattern implementation in C++](null) 
	* [112.1 Adapter Pattern](null) 
	* [112.2 Observer pattern](null) 
	* [112.3 Factory Pattern](null) 
	* [112.4 Builder Pattern with Fluent API](null) 
* [第113章 Singleton Design Pattern](null) 
	* [113.1 Lazy Initialization](null) 
	* [113.2 Static deinitialization-safe singleton](null) 
	* [113.3 Thread-safe Singeton](null) 
	* [113.4 Subclasses](null) 
* [第114章 User-Defined Literals](null) 
	* [114.1 Self-made user-defined literal for binary](null) 
	* [114.2 Standard user-defined literals for duration](null) 
	* [114.3 User-defined literals with long double values](null) 
	* [114.4 Standard user-defined literals for strings](null) 
	* [114.5 Standard user-defined literals for complex](null) 
* [第115章 Memory management](null) 
	* [115.1 Free Storage (Heap, Dynamic Allocation)](null) 
	* [115.2 Placement new](null) 
	* [115.3 Stack](null) 
* [第116章 C++11 Memory Model](null) 
	* [116.1 Need for Memory Model](null) 
	* [116.2 Fence example](null) 
* [第117章 Scopes](null) 
	* [117.1 Global variables](null) 
	* [117.2 Simple block scope](null) 
* [第118章 static_assert](null) 
	* [118.1 static_assert](null) 
* [第119章 constexpr](null) 
	* [119.1 constexpr variables](null) 
	* [119.2 Static if statement](null) 
	* [119.3 constexpr functions](null) 
* [第120章 One Definition Rule (ODR)](null) 
	* [120.1 ODR violation via overload resolution](null) 
	* [120.2 Multiply defined function](null) 
	* [120.3 Inline functions](null) 
* [第121章 Unspecified behavior](null) 
	* [121.1 Value of an out-of-range enum](null) 
	* [121.2 Evaluation order of function arguments](null) 
	* [121.3 Result of some reinterpret_cast conversions](null) 
	* [121.4 Space occupied by a reference](null) 
	* [121.5 Moved-from state of most standard library classes](null) 
	* [121.6 Result of some pointer comparisons](null) 
	* [121.7 Static cast from bogus void* value](null) 
	* [121.8 Order of initialization of globals across TU](null) 
* [第122章 Argument Dependent Name Lookup](null) 
	* [122.1 What functions are found](null) 
* [第123章 Attributes](null) 
	* [123.1 [[fallthrough]]](null) 
	* [123.2 [[nodiscard]]](null) 
	* [123.3 [[deprecated]] and [[deprecated("reason")]]](null) 
	* [123.4 [[maybe_unused]]](null) 
	* [123.5 [[noreturn]]](null) 
* [第124章 Recursion in C++](null) 
	* [124.1 Using tail recursion and Fibonnaci-style recursion to solve the Fibonnaci sequence](null) 
	* [124.2 Recursion with memoization](null) 
* [第125章 Arithmitic Metaprogramming](null) 
	* [125.1 Calculating power in O(log n)](null) 
* [第126章 Callable Objects](null) 
	* [126.1 Function Pointers](null) 
	* [126.2 Classes with operator() (Functors)](null) 
* [第127章 Client server examples](null) 
	* [127.1 Hello TCP Client](null) 
	* [127.2 Hello TCP Server](null) 
* [第128章 Const Correctness](null) 
	* [128.1 The Basics](null) 
	* [128.2 Const Correct Class Design](null) 
	* [128.3 Const Correct Function Parameters](null) 
	* [128.4 Const Correctness as Documentation](null) 
* [第129章 Parameter packs](null) 
	* [129.1 A template with a parameter pack](null) 
	* [129.2 Expansion of a parameter pack](null) 
* [第130章 Build Systems](null) 
	* [130.1 Generating Build Environment with CMake](null) 
	* [130.2 Compiling with GNU make](null) 
	* [130.3 Building with SCons](null) 
	* [130.4 Autotools (GNU)](null) 
	* [130.5 Ninja](null) 
	* [130.6 NMAKE (Microsoft Program Maintenance Utility)](null) 
* [第131章 Concurrency With OpenMP](null) 
	* [131.1 OpenMP: Parall  *s](null) 
	* [131.2 OpenMP: Parall  *s](null) 
	* [131.3 OpenMP: Parallel For Loop](null) 
	* [131.4 OpenMP: Parallel Gathering / Reduction](null) 
* [第132章 Resource Management](null) 
	* [132.1 Resource Acquisition Is Initialization](null) 
	* [132.2 Mutexes & Thread Safety](null) 
* [第133章 Storage class specifiers](null) 
	* [133.1 extern](null) 
	* [133.2 register](null) 
	* [133.3 static](null) 
	* [133.4 auto](null) 
	* [133.5 mutable](null) 
* [第134章 Linkage specifications](null) 
	* [134.1 Signal handler for Unix-like operating system](null) 
	* [134.2 Making a C library header compatible with C++](null) 
* [第135章 Digit separators](null) 
	* [135.1 Digit Separator](null) 
* [第136章 C incompatibilities](null) 
	* [136.1 Reserved Keywords](null) 
	* [136.2 Weakly typed pointers](null) 
	* [136.3 goto or switch](null) 
* [第137章 Side by Side Comparisons of classic C++ examples solved via C++ vs C++11vs C++14 vs C++17](null) 
	* [137.1 Looping through a container](null) 
* [第138章 Compiling and Building](null) 
	* [138.1 Compiling with GCC](null) 
	* [138.2 Compiling with Visual Studio (Graphical Interface) - Hello World](null) 
	* [138.3 Online Compilers](null) 
	* [138.4 Compiling with Visual C++ (Command Line)](null) 
	* [138.5 Compiling with Clang](null) 
	* [138.6 The C++ compilation process](null) 
	* [138.7 Compiling with Code::Blocks (Graphical interface)](null) 
* [第139章 Common compile/linker errors (GCC)](null) 
	* [139.1 undefined reference to `***'](null) 
	* [139.2 error: '***' was not declared in this scope](null) 
	* [139.3 fatal error: ***: No such file or directory](null) 
* [第140章 More undefined behaviors in C++](null) 
	* [140.1 Referring to non-static members in initializer lists](null) 
* [第141章 Unit Testing in C++](null) 
	* [141.1 Google Test](null) 
	* [141.2 Catch](null) 
* [第142章 C++ Debugging and Debug-prevention Tools & Techniques](null) 
	* [142.1 Static analysis](null) 
	* [142.2 Segfault analysis with GDB](null) 
	* [142.3 Clean code](null) 
* [第143章 Optimization in C++](null) 
	* [143.1 Introduction to performance](null) 
	* [143.2 Empty Base Class Optimization](null) 
	* [143.3 Optimizing by executing less code](null) 
	* [143.4 Using effcient containers](null) 
	* [143.5 Small Object Optimization](null) 
* [第144章 Optimization](null) 
	* [144.1 Inline Expansion/Inlining](null) 
	* [144.2 Empty base optimization](null) 
* [第145章 Profiling](null) 
	* [145.1 Profiling with gcc and gprof](null) 
	* [145.2 Generating callgraph diagrams with gperf2dot](null) 
	* [145.3 Profiling CPU Usage with gcc and Google Perf Tools](null) 
* [第146章 Refactoring Techniques](null) 
	* [146.1 Goto Cleanup](null) 